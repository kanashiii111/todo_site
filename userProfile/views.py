import json
from django.shortcuts import get_object_or_404
from django.views.generic import ListView
from django.shortcuts import render, HttpResponseRedirect, redirect
from django.http import JsonResponse
from django.urls import reverse
from .models import Task, TaskReminder
from .forms import TaskCreationForm, SUBJECT_CHOICES, TASKTYPE_CHOICES
from django.contrib.auth import logout
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required
from .serializers import TaskSerializer
from rest_framework import generics
import calendar
from django.utils.decorators import method_decorator
from .filters import TaskFilter
from datetime import datetime, timedelta, date, timezone
from django.db.models import Q
import requests
from django.views.decorators.csrf import csrf_exempt
from users.forms import ProfileForm
from users.models import Profile
import todo_site.settings
from django.core.management.base import BaseCommand


## ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸

@login_required(login_url='users:login')
def profileRedirect(request):
    return redirect('userProfile:settings')

@csrf_exempt
def telegram_webhook(request):
    if request.user.profile.telegram_notifications == False: return
    if request.method == "POST":
        data = json.loads(request.body)
        message = data.get("message", {})
        
        if message.get("text") == "/start":
            chat_id = message["chat"]["id"]
            response_text = (
                f"ğŸ”‘ Ğ’Ğ°Ñˆ Telegram Chat ID: `{chat_id}`\n\n"
                "1. Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ ÑÑ‚Ğ¾Ñ‚ Ğ½Ğ¾Ğ¼ĞµÑ€\n"
                "2. Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ ĞµĞ³Ğ¾ Ğ² Ğ¿Ğ¾Ğ»Ğµ 'Telegram Chat ID' Ğ½Ğ° ÑĞ°Ğ¹Ñ‚Ğµ\n"
                "3. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ\n\n"
                "Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹ Ğ±ÑƒĞ´ĞµÑ‚Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ°Ñ…!"
            )
            
            requests.post(
                f"https://api.telegram.org/bot{todo_site.settings.TELEGRAM_BOT_TOKEN}/sendMessage",
                json={
                    "chat_id": chat_id,
                    "text": response_text,
                    "parse_mode": "Markdown"
                }
            )
        
        return JsonResponse({"status": "ok"})
    
    return JsonResponse({"status": "error"}, status=400)

def send_telegram_message(chat_id, text):
    url = f"https://api.telegram.org/bot{todo_site.settings.TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        'chat_id': chat_id,
        'text': text,
        'parse_mode': 'HTML'
    }
    try:
        response = requests.post(url, json=payload)
        response.raise_for_status()  # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ HTTP
        return True
    except requests.exceptions.RequestException as e:
        print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ² Telegram: {e}")
        return False

class Command(BaseCommand):
    help = 'Send task reminders to users'

    def handle(self, *args, **options):
        now = timezone.now()
        reminders = TaskReminder.objects.filter(
            is_active=True,
            task__isCompleted=False
        ).select_related('task')

        for reminder in reminders:
            task = reminder.task
            remind_date = task.dateTime_due - timezone.timedelta(days=reminder.remind_before_days)
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ
            if now >= remind_date and (
                reminder.last_reminder_sent is None or 
                reminder.last_reminder_sent < remind_date
            ):
                # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ
                message = f"â° ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ: {task.title}\n" \
                     f"ğŸ“… Ğ¡Ñ€Ğ¾Ğº: {task.dateTime_due.strftime('%d.%m.%Y %H:%M')}\n" \
                     f"ğŸ“ {task.description or '-'}"
            
                if reminder.task.user.profile.telegram_notifications and reminder.task.user.profile.telegram_chat_id:
                    try:
                        send_telegram_message(
                            reminder.task.user.profile.telegram_chat_id,
                            message
                        )
                    except Exception as e:
                        self.stdout.write(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ² Telegram: {e}")
                        
                reminder.last_reminder_sent = now
                reminder.save()

                # Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‰ĞµĞµÑÑ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ´Ğ°Ñ‚Ñƒ
                if reminder.repeat_interval > 0:
                    new_remind_days = reminder.remind_before_days + reminder.repeat_interval
                    if new_remind_days < (task.dateTime_due - now).days:
                        reminder.remind_before_days = new_remind_days
                        reminder.save()
                    else:
                        reminder.is_active = False
                        reminder.save()

@login_required(login_url='users:login')
def settingsView(request):
    profile = get_object_or_404(Profile, user=request.user)

    if request.method == 'POST':
        if 'logout' in request.POST:
            logout(request)
            return HttpResponseRedirect(reverse('users:login'))
        if 'setTelegramNotis' in request.POST:
            profile.telegram_notifications = not profile.telegram_notifications
            profile.save() 
            return redirect("userProfile:settings")
        if 'save_chat_id' in request.POST:
            new_chat_id = request.POST.get("telegram_chat_id", '').strip()
            if new_chat_id:
                profile.telegram_chat_id = new_chat_id
                profile.save() 
                return redirect("userProfile:settings")
        if 'sendmsg' in request.POST:
            if profile.telegram_notifications != False:
                chat_id = profile.telegram_chat_id
                response_text = "Ğ¢ĞµÑÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ"
                requests.post(
                    f"https://api.telegram.org/bot{todo_site.settings.TELEGRAM_BOT_TOKEN}/sendMessage",
                    json={
                        "chat_id": chat_id,
                        "text": response_text,
                        "parse_mode": "Markdown"
                    }
                )
            else:
                chat_id = profile.telegram_chat_id
                response_text = "Ğ“Ğ°Ğ»Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¶Ğ°Ñ‚Ğ°"
                requests.post(
                    f"https://api.telegram.org/bot{todo_site.settings.TELEGRAM_BOT_TOKEN}/sendMessage",
                    json={
                        "chat_id": chat_id,
                        "text": response_text,
                        "parse_mode": "Markdown"
                    }
                )
                
    
    form = ProfileForm(instance=profile)
    return render(request, 'userProfile/settings.html', {'profile' : profile, 'form' : form})
    
## Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ¸   

class TaskListCreateView(generics.ListCreateAPIView):
    queryset = Task.objects.all()
    serializer_class = TaskSerializer
    
@login_required(login_url='users:login')
def tasksView(request):
    if request.method == 'POST':
        if 'deleteTask' in request.POST:
            task_id = request.POST.get('deleteTask')
            task = get_object_or_404(Task, id=task_id, user=request.user)
            task.delete()
            return redirect('userProfile:tasks')
        elif 'completeTask' in request.POST:
            task_id = request.POST.get('completeTask')
            task = get_object_or_404(Task, id=task_id, user=request.user)
            task.isCompleted = not task.isCompleted
            task.save()
        return redirect('userProfile:tasks')
    
    search_query = request.GET.get('search', '')
    
    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ Ğ¿Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞ¾Ğ²Ğ¾Ğ¼Ñƒ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑƒ
    tasks = Task.objects.filter(user=request.user)
    profile = request.user.profile
    
    if search_query:
        tasks = tasks.filter(
            Q(title__icontains=search_query) | 
            Q(description__icontains=search_query))

    task_filter = TaskFilter(request.GET, queryset=Task.objects.filter(user=request.user))
    tasks = task_filter.qs.order_by('dateTime_due')

    today = datetime.now().date()
    days = []
    
    for i in range(7):
        current_date = today + timedelta(days=i)
        if i == 0:
            day_name = "Ğ¡ĞµĞ³Ğ¾Ğ´Ğ½Ñ"
        elif i == 1:
            day_name = "Ğ—Ğ°Ğ²Ñ‚Ñ€Ğ°"
        else:
            day_name = current_date.strftime("%d.%m.%Y")
        
        days.append({
            'date': current_date,
            'name': day_name,
            'tasks': [task for task in tasks if task.dateTime_due.date() == current_date]
        })
    context = {
        'days': days,
        'SUBJECT_CHOICES': SUBJECT_CHOICES,
        'TASKTYPE_CHOICES': TASKTYPE_CHOICES,
        'form' : TaskCreationForm(user = request.user),
        'filter' : task_filter,
        'search_query' : search_query,
        'profile' : profile,
    }

    return render(request, 'userProfile/tasks.html', context)

@login_required(login_url='users:login')
def deleteTask(request, task_id):
    if request.method == 'POST':
        task = get_object_or_404(Task, id=task_id, user=request.user)
        task.delete()
    return redirect(request.POST.get('next', 'userProfile:tasks'))

@login_required(login_url='users:login')
def createTask(request):
    if request.method == 'POST':
        form = TaskCreationForm(request.POST, user=request.user)
        if form.is_valid():
            form.save()
            return redirect('userProfile:tasks')
    else:
        form = TaskCreationForm(user=request.user)
    return render(request, 'userProfile/create_task.html', {'form': form})

@login_required(login_url='users:login')
def editTask(request, task_id):
    task = get_object_or_404(Task, id=task_id, user=request.user)

    if request.method == 'POST':
        form = TaskCreationForm(request.POST, instance=task, user=request.user)
        if form.is_valid():
            form.save()
            return redirect('userProfile:tasks')
    else:
        # Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ñ„Ğ¾Ñ€Ğ¼Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸
        form = TaskCreationForm(instance=task, user=request.user)
    
    return render(request, 'userProfile/task_edit.html', {
        'form': form,
        'task': task
    })

@login_required(login_url='users:login')
def get_task_data(request, task_id):
    task = get_object_or_404(Task, id=task_id, user=request.user)
    return JsonResponse({
        'title': task.title,
        'description': task.description,
        'subject': task.subject,
        'taskType': task.taskType,
        'dateTime_due': task.dateTime_due.isoformat(),
    })

## ĞšĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€ÑŒ

@method_decorator(login_required(login_url='users:login'), name='dispatch')
class CalendarView(ListView):
    model = Task
    template_name = 'userProfile/calendar.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        selected_date = self.get_date(self.request.GET.get('month', None))
        
        cal = calendar.Calendar()
        month_days = cal.monthdatescalendar(selected_date.year, selected_date.month)
        
        tasks = Task.objects.filter(
            user=self.request.user,
        ).select_related('user').order_by('dateTime_due')
        
        context.update({
            'calendar': month_days,
            'prev_month': self.prev_month(selected_date),
            'next_month': self.next_month(selected_date),
            'current_month': selected_date,
            'today': date.today(),
            'tasks': tasks,
            'month_name': self.get_month_name(selected_date),
            'SUBJECT_CHOICES': SUBJECT_CHOICES,
            'TASKTYPE_CHOICES': TASKTYPE_CHOICES,
            'form' : TaskCreationForm(user = self.request.user),
        })
        return context

    def get_date(self, req_month):
        """ĞŸĞ°Ñ€ÑĞ¸Ñ‚ Ğ´Ğ°Ñ‚Ñƒ Ğ¸Ğ· Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ° Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ğ¸Ğ»Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ´Ğ°Ñ‚Ñƒ"""
        if req_month:
            year, month = map(int, req_month.split('-'))
            return date(year, month, day=1)
        return date.today()

    def prev_month(self, d):
        """Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ URL Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ Ğ´Ğ»Ñ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ³Ğ¾ Ğ¼ĞµÑÑÑ†Ğ°"""
        first = d.replace(day=1)
        prev_month = first - timedelta(days=1)
        return f'month={prev_month.year}-{prev_month.month}'

    def next_month(self, d):
        """Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ URL Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ¼ĞµÑÑÑ†Ğ°"""
        days_in_month = calendar.monthrange(d.year, d.month)[1]
        last = d.replace(day=days_in_month)
        next_month = last + timedelta(days=1)
        return f'month={next_month.year}-{next_month.month}'

    def get_month_name(self, date_obj):
        """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ»Ğ¾ĞºĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¼ĞµÑÑÑ†Ğ°"""
        month_names = [
            'Ğ¯Ğ½Ğ²Ğ°Ñ€ÑŒ', 'Ğ¤ĞµĞ²Ñ€Ğ°Ğ»ÑŒ', 'ĞœĞ°Ñ€Ñ‚', 'ĞĞ¿Ñ€ĞµĞ»ÑŒ', 'ĞœĞ°Ğ¹', 'Ğ˜ÑĞ½ÑŒ',
            'Ğ˜ÑĞ»ÑŒ', 'ĞĞ²Ğ³ÑƒÑÑ‚', 'Ğ¡ĞµĞ½Ñ‚ÑĞ±Ñ€ÑŒ', 'ĞĞºÑ‚ÑĞ±Ñ€ÑŒ', 'ĞĞ¾ÑĞ±Ñ€ÑŒ', 'Ğ”ĞµĞºĞ°Ğ±Ñ€ÑŒ'
        ]
        return month_names[date_obj.month - 1]
        


